# Exploring Data with the Tidyverse {#tidyverse}

Now that we have covered the basics of the R language, it is time to analyse some data. The next four sessions use water quality data from a reticulation network which we analyse for compliance with regulations. 

This chapter has the following learning objectives:

* Understand the principles of R packages
* Load and describe a CSV data set
* Summarise rectangular data

The data for this chapter is available in the `casestudy1` folder of your [RStudio project](https://github.com/pprevos/r4h2o).

## R Libraries

One of the most powerful features of the R language is that developers can write extensions, the so-called packages. R has a large community of users who develop code and make it freely available to other users. 

Thousands of specialised packages are available that undertake a vast range of complex tasks. You can, for example, use R as a GIS and analyse spatial data, or implement machine learning. Other packages help you to access data from various sources, such as SQL databases. R packages can also help you present the results of your analysis as a presentation, report or interactive dashboard.

The majority of R packages are available on [CRAN](https://cran.r-project.org/), the *Comprehensive R Archive Network*. You can install packages in R with the `install.packages()` function. Within RStudio, you install packages in the *Tools* menu. When you install a package, RStudio downloads a library of files and stores them for future use. The words package and library are sometimes used interchangeably. In R, a package is a collection of R functions, data and compiled code. The location where the packages are stored is called the library.

The CRAN repository contains many packages with specific functionality to analyse water, some of which are:

* *[baytrends](https://cran.r-project.org/web/packages/baytrends/index.html)*: Long term water quality trend analysis.
* *[biotic](https://cran.r-project.org/web/packages/biotic/index.html)*: Calculation of Freshwater Biotic Indices.
* *[CityWaterBalance](https://cran.r-project.org/web/packages/CityWaterBalance/index.html)*: Track flows of water through an urban system.
* *[driftR](https://cran.r-project.org/web/packages/driftR/index.html)*: Drift correcting water quality data.
* *[EmiStatR](https://cran.r-project.org/web/packages/EmiStatR/index.html)*: Emissions and statistics in R for wastewater and pollutants in combined sewer systems.

Each package has formal documentation, and some packages have vignettes, which explain how to use the specific functions in a bit more detail.

## Introducing the Tidyverse

One of the most popular collections of R packages for analysing data is the [Tidyverse](https://www.tidyverse.org/), developed by R guru Hadley Wickham and many others. Doing 'tidy' data science is a style of coding that has a strong following. Tidy data science relates to writing code and cleaning data in a way that promotes reproducibility.

The Tidyverse packages provide enhanced functionality to extract, transform, visualise and analyse data. The features offered by these packages are more versatile, easier to use and understand than the base R code.

Computer scientists call software like the Tidyverse ‘syntactic sugar‘, which means that it simplifies the syntax, closer to human language.

>**Practice Task**: Install the Tidyverse collection of packages using `install.packages("tidyverse")`.

Installing the complete Tidyverse can take a little while. If you are working with the desktop version, make sure you have sufficient access rights to install and run the packages.

After you install a package, you need to initialise it with the `library()` function. 

```{r}
library(tidyverse)
```

When you initiate the Tidyverse library, R shows feedback in the console that the following packages are loaded by default:

* *[dplyr](https://dplyr.tidyverse.org/)*: Manipulating and analysing data.
* *[ggplot2](https://ggplot2.tidyverse.org/)*: Visualise data.
* *[forcats](https://forcats.tidyverse.org/)*: Working with factor variables.
* *[purrr](https://purrr.tidyverse.org/)*: Functional programming.
* *[readr](https://readr.tidyverse.org/)*: Read and write read rectangular data (CSV files and similar).
* *[stringr](https://stringr.tidyverse.org/)*: Manipulate text.
* *[tibble](https://tibble.tidyverse.org/)*: Working with rectangular data.
* *[tidyr](https://tidyr.tidyverse.org/)*: Data transformation.

You can ignore the conflicts at the end. These warnings relate to functions that override existing functionality and are not a concern for now.

When you use a function from a package without first calling it with the `libary()` function, R will not recognise the function, or use another one with the same name from the base package. You can use functions from packages without calling the library by adding the library name in front of the function, followed by two colons, e.g.: `readr::read_csv()`. You only need to use this method to resolve conflicts.

The Tidyverse developers frequently update the software. You can see if updates are available, and optionally install them, by running `tidyverse_update()`. You can also upgrade packages in the *Tools > Check for Package Updates* menu in RStudio.

These are not the only packages that follow the Tidyverse principles. The official repositories contain more than 20 packages. Many other developers also follow the principles of the Tidyverse, such as [Tidytext](https://juliasilge.github.io/tidytext/) for text mining. If you like to explore any of these, you will need to install them first.

## Case Study 1

The first case study looks at water quality data in four towns on the island of Gormsey. Each town has a set of sample points at the customer tap. Gormsey’s laboratory regularly samples these taps and tests the water for a range of parameters.

The laboratory stores all results in a CSV file, which we use for this case study. In reality, water utilities sample hundreds of different parameters at different frequencies at the water treatment plant and the water network. Analysing this data is a common activity for water professionals. The data for this case study only contains three parameters.

This file contains one year of samples over various sample points for:

- [Turbidity](https://en.wikipedia.org/wiki/Turbidity)
- [Escherichia coli](https://en.wikipedia.org/wiki/Escherichia_coli) (E. coli) 
- [Chlorine](https://en.wikipedia.org/wiki/Water_chlorination)
- [Trihalomethanes](https://en.wikipedia.org/wiki/Trihalomethane) (THMs). 

Turbidity is a measure of the cloudiness or opaqueness of a liquid. It is not only a measure of the aesthetics of drinking water, it is also a indicator of possible further issues. The unity for turbidity are NTU, or Nephelometric Turbidity Unit. The basic instrument incorporates a single light source and a photodetector to sense the scattered light. Internal lenses and apertures focus the light onto the sample, while the photodetector is set at 90 degrees to the direction of the incident light to monitor scattered light.

Escherichia coli (abbreviated as E. coli) are a type of bacteria found in the environment, foods, and intestines of people and animals. Although most strains of E. coli are harmless, others can make you sick. Some kinds of E. coli can cause diarrhea, while others cause urinary tract infections, respiratory illness and pneumonia, and other illnesses. E. coli numbers in freshwater are determined by counting the number of yellow and yellow brown colonies incubated at 35.0º C for 22--24 hours. The addition of urea substrate confirms that colonies are E. coli. The presence of this bacteria provides direct evidence of fecal contamination from warm-blooded animals and is an essential indicator in water quality management.

Chlorine is an effective control against the presence of bacteria in drinking water. It is usually dosed at the water treatment plant. Chlorine does get broken down into other components as  it travels through the network. A main consideration for managing a water network is that chlorine levels maintain at sufficient levels to disinfect the water. The levels of chlorine should not be too low  to maintain water safety, but not be too high to prevent customer complaints or even negative health impacts at extreme levels.

THMs are a group of chemical compounds that are predominantly formed as a by-product when chlorine is used to disinfect drinking water. Long-term exposure to high level of these by-products can cause diseases such as cancer. 

## Exploring the Case Study Data

The first step when you receive a new data set is to explore and review its content. Before we start exploring this data, we need to load the Tidyverse collection of packages with the function call `library(tidyverse)`. If we don't do this first, R will not recognise the functions.

In the previous chapter we have seen scalar (singular) and vector variables. Most data is, however, two-dimensional stored in tables. In R, a table is either a matrix or a data frame. Matrices are only used for mathematical analysis, while data frames are more like database tables or a spreadsheet.

A data frame has variables (columns) and observations (rows). The top row contains the variable names and the remainder the values. So effectively, a data frame is a collection of vectors. Each of the variables needs to have the same number of observations and all observations within a variable need to be of the same data type, e.g. dates, text and numbers.

The *readr* package of the Tidyverse contains functions to read and write CSV files. R also has a base function to read CSV files, but the Tidyverse alternative is faster and better able to assign the correct data formats. You can load the data with the `read_csv()` function.

>**Practice Task**: Create an R script and copy and evaluate the code as you read through this chapter.

The best way to learn is to type the expressions in this chapter as you read the text. A productive way to comprehend the information is to change the examples and review the difference in the results.

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(tidyverse)
gormsey <- read_csv("../casestudy1/gormsey.csv")
```

```{r message=FALSE, warning=FALSE, eval=FALSE}
library(tidyverse)
gormsey <- read_csv("casestudy1/gormsey.csv")
```

The text between quotation marks is the path to the file and its name. Note that R uses the forward-slash `/`, common in Unix systems, and not the Windows backslash (`\`) to form a path. Every R session has a working directory, and all paths are relative to that folder. When you work in a project, RStudio saves the working directory for future sessions. 

You can find see the current working directory with the `getwd()` function, which you can run in the console. Without a working directory, you would have to specify the complete path, such as: 

`C:/Users/peterp/Documents/r4h2o/casestudy2/gormsey.csv`. 

In this example, the working directory is `C:/Users/peterp/Documents/r4h2o/`. Using an RStudio project saves you having to type this every time.

This function reads the content of the CSV file into memory. The content of the file itself is not changed, unless you specifically write it to disk. Best practice in data science is to not change the raw data to ensure reproducibility of the analysis. 

The `read_csv()` function assumes that the first row contains the field names and the following rows contain the data, organised in columns. After you type the quotation marks, you can use the tab button to select a file.

This function has many options you can use to fine-tune how R reads the data. The most common option is `skip = n`, which instructs the function to ignore the first `n` rows. This is useful because many CSV files contain metadata in the first few rows. [Chapter 8]{#cleaning} discusses unruly CSV files in more detail.

After loading the data, R shows a summary. To view the data in the console, simply type `gormsey` ane `ENTER`. 

```{r}
gormsey
```

The Gormsey data is a tibble (a data frame) with `r nrow(gormsey)` rows and `r ncol(gormsey)` columns in various data formats, indicated between `<>`. The double format (`dbl`) are real numbers. The data also contains a date and some character (`chr`) values.

The `gormsey` variable is also visible in the *Environment* tab. The `gormsey` variable is a data frame, which is a tabular set of data with rows (observations) and columns (variables), very much like a spreadsheet. When you click on it, it will appear as a read-only table.

Each column is a variable, which is also called a data field or a parameter. Each row holds an observation or a measurement. The table below shows two rows of the data frame.

The data for this case study uses synthetic (simulated) laboratory data. The data in this case study has the following fields:

* `Sample_No`: Reference number of the sample.
* `Date_Sampled`: The sampling date.
* `Sample_Point`: The reference number of the sample point.
* `Town`: The town in Gormsey.
* `Measure`: The type of measurement.
* `Result`: The result of the laboratory test.
* `Units`: The units of the result (NTU, mg/l or orgs/100ml).

Each of these columns within a data frame is a vector, like the ones we saw in the previous session. All data frames are rectangular, which means that all vectors in a data frame have the same length.

Within the Tidyverse, a data frame is called a *Tibble*. This quaint term is a reference to the New Zealand accent of the leading developer of this software, Hadley Wickham. Tibbles have the same properties as a data frame but have some extended capabilities to make life easier. The words data-frame and tibble are used interchangeably in this book.

The data is read into memory and any changes you make to the data are not written to disk unless you explicitly do so. When you close R Studio, the content of the memory is saved to disk, but the CSV file remains untouched. Changing the raw data on disk is not good practice as you want to be able to reproduce your analysis.

R can read many types of data. Some specialised extensions can connect R to Excel spreadsheets, SQL databases, scrape data from websites, GIS layers, and many other sources. 

Spreadsheets are not ideal sources for corporate data. Nevertheless, many organisations maintain spreadsheets as their single source of truth. If a spreadsheet is indeed your only solution to store data, you should stick to some simple rules to be able to easily use it in R, or any other data science package:

* Use only the top row as a header.
* Don't use colours to indicate values.
* Prevent using spaces in column names.
* Don't add any calculations in the data tab. 
* Every cell should be a data point or remain empty.

Following these guidelines, you can store your data in a clean way that simplifies analysing the results with R, or any other analytical software.

### Inspect the data

The next step is to inspect the data. When you type the name of the variable in the console, RStudio only displays the first ten rows. Any columns that don't fit on the screen are truncated.

The `names()` function displays all names of the columns as a vector of characters.

The `dim()` function shows the number of rows and columns in a data frame.

```{r}
names(gormsey)

dim(gormsey)
```

> Use the `nrow()` and `ncol()` functions on the Gormsey data. What does it show?

Answer: The `nrow()` and `ncol()` functions list the number of rows and columns for a data frame. The result of each function call is a single number. The `dim()` function shows both results in a vector of two numbers.

### Explore the content

We now know how much data we have and what type of information it contains. R and the Tidyverse also have several functions to view the content of a data frame.

When you type the name of a variable in the console, R will show you the data. With large sets, the results will very quickly scroll through the screen. The Tidyverse will only show the first few rows of a data frame or Tibble and truncates any columns that don't fit on the screen.

The Tidyverse function to summarise a data frame is `glimpse()`. When executing this function on the Gormsey data, we see:

```{r}
glimpse(gormsey)
```

The `glimpse()` function shows the number of rows and columns, the names of the variables, their types and the first few data points. You can also obtain this information by clicking on the triangle next to the variable name in the Environment tab in RStudio.

The `View()` function (note the capital V) opens the data in a separate read-only window. This function is the most convenient way to inspect data visually. You can also view the data this way by clicking on the variable name in the Environment tab. You cannot edit the data, but you can sort the information by column by clicking on the variable name.

```{R eval=FALSE, include=FALSE}
View(gormsey)
```

### Explore variables

To view any of the variables within a data frame, you need to add the column name after a `$`, e.g. `gormsey$Result`. When you execute this command, R shows a vector of the observations within this variable. You can use this vector in calculations, as explained in the previous session. If you type a `$` after `gormsey`, RStudio will show a list of the available variables that you can pick with the arrow buttons and the enter key.

If you want to use only a subset of a vector, you can indicate the index number between square brackets. For example: `gormsey$Results[1:10]` shows the first ten results.

R has various ways to view or analyse a subset of the data. The most basic approach is to add the number of the row and column between square brackets. For a data frame, you use two numbers: `[rows, columns]`. When you omit either the row or column number, R shows all available rows or columns. Note that `gormsey$Date` result in a vector and `gormsey[, 2]` results in a new data frame.

For example, `turbidity[1:10, 4:5]` shows the first ten rows and the fourth and fifth variable. When there is no value in either the place for the rows or the columns, R shows all values. 

Please note that the tibble functionality in Tidyverse will truncate the output so it fits on the screen.

```{R}
gormsey[12:13, ] ## Show all variables for row 12 to 13

gormsey[, 4:5]  ## Show all rows with column four and five

gormsey$Date[1:6] ## Show the first six values in the Date variable
```

This syntax can also include the names of variables, e.g. `gormsey[1:10, c("Town", "Result")]` shows the first ten rows of the Town and the Result variables.

Besides numerical values, you can also add formulas as indices, for example: `gormsey[, n * 2]`. Please note that R is a mathematical language and the index numbers thus start at one. In generic programming languages, the index starts at zero. 

>**Practice Task**: What is the sample number of the last sample in the Gormsey data? Hint, use the `nrow()` function.

Answer: 

```{r}
gormsey$Sample_No[nrow(gormsey)]
```

## Filtering data

You can also filter the data using conditions. If, for example, you like to see only the turbidity data, then you can subset the data:

```{R eval=FALSE}

gormsey[gormsey$Measure == "Turbidity", ]
```

This method looks similar to what we discussed above. The difference is that the row indicator now shows an equation. When you execute the equation between brackets separately, you see a list of values that are either `TRUE` or `FALSE`. These values indicate whether the variable at that location meets the condition. For example, the following code results in a vector with the values `TRUE` and `FALSE`.

```{R}
a <- 1:2
a == 1
```

Variables that are either TRUE or FALSE are called boolean or logical, and they are the building blocks of computer science. These variables are useful to indicate conditions and can also be used in calculations. The code below results in a vector with the values 2 and 0.

```{R}
a <- c(TRUE, FALSE)
a * 2
```

You can also use all the common [relational operators](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Comparison.html) to test for complex conditions:

* `x < y` less than
* `x > y ` greater than
* `x <= y` less than or equal to
* `x >= y` greater than or equal to
* `x == y` equal to each other
* `x != y` not equal to each other

R also evaluates relations between character strings, using alphabetical order. In R, `"small" > "large"` results in TRUE because 's' comes after 'l'.

You can build elaborate conditionals by combining more than one condition with logical operations. Some of the most common options are:

* `! x`: not ($\lnot x$)
* `x & y`: logical and ($x \land y$)
* `x | y`: logical or ($x \lor y$)

An example of a logical operation would be the expression `"small" > "large" & 1 == 2`, which results in `FALSE` because the first condition is true, but the second one is false, so they are not both true.

The Tidyverse method uses the `filter()` function, which is more convenient than using square brackets. The first parameter in this function is the data frame you need to filter, and the second parameter is the condition. 

```{R}
turbidity <- filter(gormsey, Measure == "Turbidity")
```

Note that this method is tidier than the brackets method because we don't have to add the data frame name and `$` to the variables. Figure \@ref(fig:filter) illustrates the principles of filtering a data frame.

```{r filter, fig.cap='Filtering a data frame: `filter(gormsey, Measure == "Turbidity")`', echo=FALSE, out.width = '100%'}
knitr::include_graphics("images/filter.png")
```

We can apply this knowledge to our case study to test subsets of the data: `filter(gormsey, Town == "Tarnstead" & Measure == "Turbidity" & Result > 1)` shows the turbidity samples in Tarnstead with a result greater than 1 NTU. Note that testing for equality requires two equal signs.

>**Practice Task**: How many turbidity results in all Towns, except Strathmore, are lower than 0.1 NTU?

Answer: Subset the data for all results less than 0.1 NTU *and* where the Town is not Strathmore. The `nrow()` function counts the results: 

```{r}
nrow(filter(gormsey, Town != "Strathmore" & Measure == "Turbidity", Result < 0.1))
```

## Counting results

The last exploratory activity discussed in this chapter is counting the number of results. The `table()` function in base R lets you quickly view the content of a data frame or a vector. To find out how many samples each measure has, you can use:

```{r}
table(gormsey$Measure)
```

The Tidyverse equivalent of this function is `count()`. The equivalent of the previous example is `count(gormsey, measure)`. Note the difference in syntax. The first argument in the function is the data frame, and the second is the variable we want to count. 

We can now combine these functions to create a table of the number of turbidity results for each Town. First, we create a subset of the data, and then we count the results. The output of this function is a new data frame with the results of the count. The `name = ` parameter defines the name of the new variable.

```{r}
turbidity_count <- count(turbidity, Town, name = "Samples")
turbidity_count
```

Two further useful functions are `length()` and `unique()`. These two functions result in the length of a vector and the distinct values within a vector.

```{r}
length(gormsey$Measure)

unique(gormsey$Measure)
```

## Quiz 2: Exploring Water Quality Data

You now have reviewed a series of functions that you can use to load and explore the laboratory data. With this knowledge, you can complete the next five quiz questions.

Load the Gormsey water quality data from the first case study and answer these five questions.

### Question 1
How many results does the Gormsey data contain?

### Question 2
How many E. coli results were recorded in Gormsey? 

### Question 3
What is the maximum turbidity measurement in Blancathey?

### Question 4
What is the median THM result of the samples in Swadlincote and Wakefield?

### Question 5
How many E Coli results breached the regulations? The limit for E Coli is 0 org/100ml.

That's it for the second quiz. If you get stuck, you can find the answers in the [appendix](#quiz2).

## Further Study

### Packages

It can be a daunting experience to explore the thousands of specialised packages that the R language has to offer. Most online searches lead you to the [CRAN website](ttps://cran.r-project.org/), which hosts most packages. Each package has a PDF refenrece manual that lists all the help files. This documents can be a bit cryptic. Many package also include vignettes, which provide a more narrative introduction to the added functionality.

For example, the *[CityWaterBalance](https://cran.r-project.org/web/packages/CityWaterBalance/)* package has both a reference manual and a vignette. When you install a package, the vignette is downloaded to your system. You can view them with the `vignette()` function. Without a parameter, it will show a list of all available vignettes.

### Loading data

R can't only read CSV files. Several R libraries provide additional functionality to read other file formats, such as:

* [readxl](https://readxl.tidyverse.org/): Tidyverse package to read Excel files.
* [RODBC](https://cran.r-project.org/web/packages/RODBC/index.html): Interface for databases such as SQL.
* [rvest](https://rvest.tidyverse.org/): Tidyverse package to scrape data from websites.

>**Practice Task**: Before you proceed to the next chapter, try and load a CSV of Excel file you use in your daily work and explore the data to practice your skills.

The [next chapter](#statistics) explains how to use R and the Tidyverse to analyse the data in detail and determine whether the results are following the relevant regulations. 
